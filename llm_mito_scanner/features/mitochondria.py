# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/03_get-mitochondrial-sequences.ipynb.

# %% auto 0
__all__ = ['get_structural_nuclear_genes_for_mitochondrial_diseases', 'load_omim_map', 'fetch_entrez_id_documents',
           'get_gene_loci_from_entrez_document', 'get_sequence_from_file', 'get_sequences_from_loci']

# %% ../../nbs/03_get-mitochondrial-sequences.ipynb 3
import pandas as pd
from Bio import SeqIO, Entrez
from tqdm.auto import tqdm
from yaml import safe_load
from pathlib import Path
import json

# %% ../../nbs/03_get-mitochondrial-sequences.ipynb 8
# Download sequences from MITOMAP
def get_structural_nuclear_genes_for_mitochondrial_diseases() -> pd.DataFrame:
    """
    Get structural nuclear genes for mitochondrial diseases from MITOMAP.
    """
    genes = pd.read_html(
        "https://www.mitomap.org/foswiki/bin/view/MITOMAP/NuclearGenesStructural",
        match="Complex"
    )[0].dropna(how='all')
    genes.loc[:, 'Complex'] = genes.Complex.fillna(method='ffill')
    genes.reset_index(drop=True, inplace=True)
    genes.loc[:, 'OMIM'] = genes.OMIM.astype(int).astype(str)
    return genes

# %% ../../nbs/03_get-mitochondrial-sequences.ipynb 13
def load_omim_map(data_path: Path):
    omim_map_df = pd.read_csv(data_path / "raw/mim2gene.txt", sep="\t", skiprows=4)
    omim_map_df.columns = ["OMIM", "entry_type", "entrez_gene_id", "gene_symbol", "ensembl_gene_id"]
    omim_map_df.loc[:, 'OMIM'] = omim_map_df.OMIM.astype(int)
    return omim_map_df

# %% ../../nbs/03_get-mitochondrial-sequences.ipynb 22
def fetch_entrez_id_documents(
    gene_ids: list[str], 
    write_path: Path
) -> list[SeqIO.SeqRecord]:
    """
    """
    already_written_gene_ids = [p.stem for p in (write_path.glob("*.json"))]
    search_gene_ids = [gid for gid in gene_ids if str(gid) not in already_written_gene_ids]
    if len(search_gene_ids) == 0:
        return
    gene_id_efetch_response = Entrez.efetch(
        "gene",
        id=",".join(search_gene_ids),
        retmode="xml"
    )
    write_pbar = tqdm(total=len(search_gene_ids))
    try:
        for result in Entrez.parse(gene_id_efetch_response):
            result_gene_id = result.get("Entrezgene_track-info", {}).get("Gene-track", {}).get("Gene-track_geneid", None)
            if result_gene_id is None:
                raise ValueError("Failed to get gene id from result")
            with (write_path / f"{result_gene_id}.json").open("w+") as f_out:
                json.dump(result, f_out)
            write_pbar.update(1)
    except ValueError as e:
        raise e
    finally:
        write_pbar.close()

# %% ../../nbs/03_get-mitochondrial-sequences.ipynb 26
def get_gene_loci_from_entrez_document(path: Path, heading_filter: str = None) -> list[str]:
    with path.open("r") as f:
        doc = json.load(f)
    #return doc
    gene_loci = doc.get("Entrezgene_locus")
    if heading_filter is not None:
        gene_loci = [loci for loci in gene_loci if loci.get("Gene-commentary_heading") == heading_filter]
    return gene_loci

# %% ../../nbs/03_get-mitochondrial-sequences.ipynb 32
def get_sequence_from_file(fasta_path: Path, start: int, end: int):
    sequence_record = next(SeqIO.parse(fasta_path.resolve(), "fasta"))
    selected_sequence = sequence_record.seq[start: end + 1]
    return selected_sequence


def get_sequences_from_loci(
    genome_fasta_path: Path, 
    sequence_write_path: Path, 
    entrez_gene_id: str, 
    sequence_docs: list[dict]
) -> list[str]:
    gene_sequence_write_path = sequence_write_path / entrez_gene_id
    if not gene_sequence_write_path.exists():
        gene_sequence_write_path.mkdir(parents=True)
    for doc in sequence_docs:
        sequence_accession = doc.get("Gene-commentary_accession", None)
        sequence_version = doc.get("Gene-commentary_version", None)
        sequence_loci = doc.get("Gene-commentary_seqs", [])
        sequence_reference_path = genome_fasta_path / f"{sequence_accession}.{sequence_version}.fasta"
        if not sequence_reference_path.exists():
            raise FileNotFoundError(f"Could not find reference fasta at {sequence_reference_path.resolve()}")
        for loci in sequence_loci:
            loci_interval = loci.get("Seq-loc_int", {}).get("Seq-interval", {})
            loci_start = loci_interval.get("Seq-interval_from", None)
            loci_to = loci_interval.get("Seq-interval_to", None)
            loci_strand = loci_interval.get("Seq-interval_strand", {})
            loci_gi = loci_interval.get("Seq-interval_id", {}).get("Seq-id", {}).get("Seq-id_gi", None)
            loci_sequence_path = gene_sequence_write_path / f"{loci_gi}.fasta"
            if not loci_sequence_path.exists():
                if loci_start is None:
                    raise ValueError("Sequence start is None")
                if loci_to is None:
                    raise ValueError("Sequence end is None")
                if loci_gi is None:
                    raise ValueError("GenInfo Identifier is None")
                loci_sequence = get_sequence_from_file(
                    sequence_reference_path,
                    start=int(loci_start),
                    end=int(loci_to)
                )
                loci_sequence_record = SeqIO.SeqRecord(
                    seq=loci_sequence,
                    id=f"gid|{entrez_gene_id}|gi|{loci_gi}"
                )
                with loci_sequence_path.open("w+") as out:
                    SeqIO.write([loci_sequence_record], out, "fasta")
