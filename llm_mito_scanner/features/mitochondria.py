# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/archive/07_get-mitochondrial-sequences.ipynb.

# %% auto 0
__all__ = ['get_structural_nuclear_genes_for_mitochondrial_diseases',
           'get_non_structural_nuclear_genes_for_mitochondrial_diseases', 'load_omim_map', 'fetch_entrez_id_documents',
           'get_gene_loci_from_entrez_document']

# %% ../../nbs/archive/07_get-mitochondrial-sequences.ipynb 3
import pandas as pd
from Bio import SeqIO, Entrez
from tqdm.auto import tqdm
from yaml import safe_load
from pathlib import Path
import json

# %% ../../nbs/archive/07_get-mitochondrial-sequences.ipynb 8
# Download sequences from MITOMAP
def get_structural_nuclear_genes_for_mitochondrial_diseases() -> pd.DataFrame:
    """
    Get structural nuclear genes for mitochondrial diseases from MITOMAP.
    """
    genes = pd.read_html(
        "https://www.mitomap.org/foswiki/bin/view/MITOMAP/NuclearGenesStructural",
        match="Complex"
    )[0].dropna(how='all')
    genes.loc[:, 'Complex'] = genes.Complex.fillna(method='ffill')
    genes.reset_index(drop=True, inplace=True)
    genes.loc[:, 'OMIM'] = genes.OMIM.astype(int).astype(str)
    return genes

# %% ../../nbs/archive/07_get-mitochondrial-sequences.ipynb 10
def get_non_structural_nuclear_genes_for_mitochondrial_diseases() -> pd.DataFrame:
    """
    Get non-structural nuclear genes for mitochondrial diseases from MITOMAP.
    """
    genes = pd.read_html(
        "https://www.mitomap.org/foswiki/bin/view/MITOMAP/NuclearGenesNonStructural",
        match="Complex"
    )[0].dropna(how='all')
    genes = genes.iloc[1:, :]
    genes.loc[:, 'Complex'] = genes.Complex.fillna(method='ffill')
    genes.reset_index(drop=True, inplace=True)
    genes.loc[:, 'OMIM'] = genes.OMIM.str.split(" ")
    # Expand the OMIM column
    genes = genes.explode('OMIM')
    return genes

# %% ../../nbs/archive/07_get-mitochondrial-sequences.ipynb 13
def load_omim_map(data_path: Path):
    omim_map_df = pd.read_csv(data_path / "raw/mim2gene.txt", sep="\t", skiprows=4)
    omim_map_df.columns = ["OMIM", "entry_type", "entrez_gene_id", "gene_symbol", "ensembl_gene_id"]
    omim_map_df.loc[:, 'OMIM'] = omim_map_df.OMIM.astype(int)
    return omim_map_df

# %% ../../nbs/archive/07_get-mitochondrial-sequences.ipynb 22
def fetch_entrez_id_documents(
    gene_ids: list[str], 
    write_path: Path,
    tqdm_kwargs: dict = None
) -> list[SeqIO.SeqRecord]:
    """
    Get summary documents for the given entrez gene ids.
    """
    already_written_gene_ids = [p.stem for p in (write_path.glob("*.json"))]
    search_gene_ids = [gid for gid in gene_ids if str(gid) not in already_written_gene_ids]
    if len(search_gene_ids) == 0:
        return
    gene_id_efetch_response = Entrez.efetch(
        "gene",
        id=",".join(search_gene_ids),
        retmode="xml"
    )
    write_pbar = tqdm(total=len(search_gene_ids), **tqdm_kwargs)
    try:
        for result in Entrez.parse(gene_id_efetch_response):
            result_gene_id = result.get("Entrezgene_track-info", {}).get("Gene-track", {}).get("Gene-track_geneid", None)
            if result_gene_id is None:
                raise ValueError("Failed to get gene id from result")
            with (write_path / f"{result_gene_id}.json").open("w+") as f_out:
                json.dump(result, f_out)
            write_pbar.update(1)
    except ValueError as e:
        raise e
    finally:
        write_pbar.close()


def get_gene_loci_from_entrez_document(path: Path, heading_filter: str = 'Reference GRCh38.p14 Primary Assembly') -> list[str]:
    with path.open("r") as f:
        doc = json.load(f)
    #return doc
    gene_loci = doc.get("Entrezgene_locus")
    if heading_filter is not None:
        gene_loci = [loci for loci in gene_loci if loci.get("Gene-commentary_heading") == heading_filter]
    return gene_loci

# %% ../../nbs/archive/07_get-mitochondrial-sequences.ipynb 31
# def get_sequences_from_loci(
#     genome_fasta_path: Path, 
#     sequence_write_path: Path, 
#     entrez_gene_id: str, 
#     sequence_docs: list[dict]
# ) -> list[str]:
#     gene_sequence_write_path = sequence_write_path / entrez_gene_id
#     if not gene_sequence_write_path.exists():
#         gene_sequence_write_path.mkdir(parents=True)
#     for doc in sequence_docs:
#         sequence_accession = doc.get("Gene-commentary_accession", None)
#         sequence_version = doc.get("Gene-commentary_version", None)
#         sequence_loci = doc.get("Gene-commentary_seqs", [])
#         sequence_reference_path = genome_fasta_path / f"{sequence_accession}.{sequence_version}.fasta"
#         if not sequence_reference_path.exists():
#             raise FileNotFoundError(f"Could not find reference fasta at {sequence_reference_path.resolve()}")
#         for loci in sequence_loci:
#             loci_interval = loci.get("Seq-loc_int", {}).get("Seq-interval", {})
#             loci_start = loci_interval.get("Seq-interval_from", None)
#             loci_to = loci_interval.get("Seq-interval_to", None)
#             loci_strand = loci_interval.get("Seq-interval_strand", {})
#             loci_gi = loci_interval.get("Seq-interval_id", {}).get("Seq-id", {}).get("Seq-id_gi", None)
#             loci_sequence_path = gene_sequence_write_path / f"{loci_gi}.fasta"
#             if not loci_sequence_path.exists():
#                 if loci_start is None:
#                     raise ValueError("Sequence start is None")
#                 if loci_to is None:
#                     raise ValueError("Sequence end is None")
#                 if loci_gi is None:
#                     raise ValueError("GenInfo Identifier is None")
#                 loci_sequence = get_sequence_from_file(
#                     sequence_reference_path,
#                     start=int(loci_start),
#                     end=int(loci_to)
#                 )
#                 loci_sequence_record = SeqIO.SeqRecord(
#                     seq=loci_sequence,
#                     id=f"gid|{entrez_gene_id}|gi|{loci_gi}"
#                 )
#                 if len(loci_sequence_record.seq) > 0:
#                     with loci_sequence_path.open("w+") as out:
#                         SeqIO.write([loci_sequence_record], out, "fasta")
