# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/03_build-translation-training-data.ipynb.

# %% auto 0
__all__ = ['parse_annotation_value', 'parse_annotation_attribute_values', 'parse_entrez_gff3_annotation_attributes',
           'get_gene_id_from_attribute_dict', 'get_sequence_from_file', 'get_gene_row_from_annotation_group',
           'get_row_sequence', 'annotate_token', 'annotate_sequence', 'get_mrna_exon_idx', 'get_annotation_exon_idx',
           'get_mrna_annotation', 'make_cds_annotation_map', 'get_cds_protein_id', 'get_cds_sequence_idx',
           'get_cds_rows', 'get_cds_annotation_idx', 'update_annotation_with_cds_annotation_idx']

# %% ../../nbs/03_build-translation-training-data.ipynb 3
import pandas as pd
from pathlib import Path
from tqdm.auto import tqdm
from Bio import SeqIO, Entrez
from Bio.SeqFeature import SeqFeature, FeatureLocation
import re
import json
from multiprocessing import Pool
import os
import sys

pd.options.mode.chained_assignment = None

# %% ../../nbs/03_build-translation-training-data.ipynb 10
def parse_annotation_value(annotation_value: str):
    """
    Handle multiple values in the attribute.
    Return value if list or dict if key-value pair
    """
    annotation_split = annotation_value.split(":")
    if len(annotation_split) == 1:
        return annotation_value
    return {annotation_split[0]: annotation_split[1]}


def parse_annotation_attribute_values(attribute_values: str) -> object:
    """
    Detect if an attribute value is really a dict or list.
    """
    value_list = attribute_values.split(",")
    if len(value_list) == 1:
        return attribute_values
    parsed_values = [parse_annotation_value(value) for value in value_list]
    # Dict within a list
    if ":" in value_list[0]:
        attribute_values = {}
        for parsed_value in parsed_values:
            attribute_values.update(parsed_value)
    # Just a list within a list
    else:
        attribute_values = parsed_values
    return attribute_values


def parse_entrez_gff3_annotation_attributes(attributes_str: str):
    """
    Convert attribute string to parsed attribute dict.
    
    Split on ';' to get attributes.
    Values can also be nested as a dict or list.
    """
    attr_list = attributes_str.split(";")
    attr_dict = {
        k: parse_annotation_attribute_values(v) for k, v in [attr.split("=") for attr in attr_list]
    }
    return attr_dict

# %% ../../nbs/03_build-translation-training-data.ipynb 16
def get_gene_id_from_attribute_dict(attribute_dict: dict):
    dbxref = attribute_dict.get("Dbxref", {})
    if isinstance(dbxref, str):
        return None
    elif isinstance(dbxref, dict):
        return dbxref.get("GeneID", None)
    else:
        return None

# %% ../../nbs/03_build-translation-training-data.ipynb 24
def get_sequence_from_file(
    start: int, end: int, strand: str = "+", 
    sequence_record: SeqIO.SeqRecord = None, fasta_path: Path = None) -> SeqIO.SeqRecord:
    """
    The Fasta file at fasta_path is a single record.
    If strand is positive, index and return sequence.
    If strand is negative, reverse the index and return.
    """
    if sequence_record is None and fasta_path is None:
        raise ValueError("Both sequence_record and fasta_path cannot be None")
    if sequence_record is None:
        sequence_record = next(SeqIO.parse(fasta_path.resolve(), "fasta"))
    selected_sequence = sequence_record[start - 1: end]
    if strand == "-":
        selected_sequence = selected_sequence.reverse_complement()
    return selected_sequence.upper()

# %% ../../nbs/03_build-translation-training-data.ipynb 27
def get_gene_row_from_annotation_group(annotations: pd.DataFrame) -> pd.Series:
    gene_rows = annotations[annotations.type == "gene"]
    if gene_rows.shape[0] == 0:
        raise ValueError("There are no 'gene' rows")
    elif gene_rows.shape[0] > 1:
        display(gene_rows)
        raise ValueError("There are more than 1 'gene' rows")
    gene_row = gene_rows.iloc[0, :]
    return gene_row


def get_row_sequence(
    sequence_row: pd.Series, 
    reference_sequence: SeqIO.SeqRecord
) -> SeqIO.SeqRecord:
    """
    """
    sequence_record = get_sequence_from_file(
        int(sequence_row.start), int(sequence_row.end), sequence_row.strand, 
        reference_sequence
    )
    sequence_record.id = sequence_row.annotation_id
    sequence_record.annotations = sequence_row.attributes_dict
    return sequence_record

# %% ../../nbs/03_build-translation-training-data.ipynb 36
def annotate_token(token: str, token_type: str, token_position: int = None):
    if token_type == "nucleotide":
        return f"[N]{token}"
    elif token_type == "aminoacid":
        if token_position is None:
            raise ValueError("token_position cannot be None if token_type is 'aminoacid'")
        return f"f[A]{token}-{token_position}"
    else:
        raise ValueError(f"Unknown token_type passed: {token_type}")
        
        
def annotate_sequence(sequence: list[str], token_type: str):
    sequence_annotation = list(
        map(
            lambda token: annotate_token(
                token, token_type
            ), 
            sequence
        )
    )
    return sequence_annotation

# %% ../../nbs/03_build-translation-training-data.ipynb 40
def get_mrna_exon_idx(mrna_row: pd.Series, exon_rows: pd.DataFrame) -> set[int]:
    exon_idx = set()
    # For each exon, mark sequence as exonic
    for idx, ex_row in exon_rows.iterrows():
        # Normalize the index values to the mrna sequence zero-index
        rel_start = ex_row.start - mrna_row.start
        rel_end = ex_row.end - mrna_row.start + 1
        exon_idx.update(list(range(rel_start, rel_end)))
    # Get intron idx
    intron_idx = [i for i in range(mrna_row.start, mrna_row.end + 1) if i not in exon_idx]
    return exon_idx


def get_annotation_exon_idx(
    annotations: pd.DataFrame, 
    reference_sequence: SeqIO.SeqRecord
):
    mrna_rows = annotations[annotations.type == "mRNA"]
    if mrna_rows.shape[0] == 0:
        return
    # Get the base sequences
    mrna_rows.loc[:, 'record'] = mrna_rows.apply(
        lambda row: get_sequence_from_file(
            row.start, row.end, row.strand, 
            reference_sequence
        ), 
        axis=1
    )
    exon_rows = annotations[annotations.type == "exon"]
    exon_rows.loc[:, 'record'] = exon_rows.apply(
        lambda row: get_sequence_from_file(
            row.start, row.end, row.strand, 
            reference_sequence
        ), 
        axis=1
    )
    # Now, assign exons to their mRNA sequences
    mrna_rows.loc[:, 'exon_idx'] = mrna_rows.apply(
        lambda row: get_mrna_exon_idx(row, exon_rows[exon_rows.parent_annotation_id == row.annotation_id]),
        axis=1
    )
    return mrna_rows

# %% ../../nbs/03_build-translation-training-data.ipynb 43
def get_mrna_annotation(gene_row: pd.Series, base_annotation: list[str], mrna_row: pd.Series) -> list[str]:
    mrna_start_norm = mrna_row.start - gene_row.start
    mrna_end_norm = mrna_row.end + 1 - gene_row.start
    mrna_annotation = base_annotation.copy()
    mrna_annotation[mrna_start_norm: mrna_end_norm] = ["[intron]"] * (mrna_end_norm - mrna_start_norm)
    assert len(mrna_annotation) == len(base_annotation)
    exon_idx = mrna_row.exon_idx
    mrna_annotation = ["[exon]" if (i in exon_idx) else val for i, val in enumerate(mrna_annotation)]
    return mrna_annotation

# %% ../../nbs/03_build-translation-training-data.ipynb 47
def make_cds_annotation_map(annotation_idx: list[(int, int)], protein_id: str, protein_path: Path):
    """
    Get our protein annotation, indexed to be applied to the base annotation.
    """
    # Load protein sequence
    protein = next(SeqIO.parse(protein_path / f"{protein_id}.fasta", "fasta"))
    protein_annotations = []
    for char in list(protein.seq):
        char_multiple = char * 3
        char_annotation = [f"[A]-{char}-{i+1}" for i, char in enumerate(char_multiple)]
        protein_annotations.extend(char_annotation)
    protein_annotations.extend([f"[A]-[stop]-{i+1}" for i in range(3)])
    idx_list = []
    for idx in annotation_idx:
        idx_index = reversed(list(range(idx[0], idx[1])))
        idx_list.extend(idx_index)
    annotation_map = pd.Series(idx_list, name='index').to_frame()
    annotation_map.loc[:, 'annotation'] = protein_annotations
    return annotation_map.set_index("index").annotation.to_dict()


def get_cds_protein_id(cds_rows: pd.DataFrame) -> str:
    protein_id_list = cds_rows.protein_id.unique().tolist()
    if len(protein_id_list) == 0:
        raise ValueError("For some reason this group of CDS don't code for protein?")
    if len(protein_id_list) > 1:
        raise ValueError("Multiple proteins for this group of CDS")
    return protein_id_list[0]


def get_cds_sequence_idx(cds_rows: pd.DataFrame, reference_sequence: SeqIO.SeqRecord) -> list[(int, int)]:
    if cds_rows.shape[0] == 0:
        return
    strand = cds_rows.strand.unique().tolist()[0]
    cds_rows = cds_rows.sort_values("start", ascending=strand == "+")
    cds_length = (cds_rows.end - cds_rows.start).sum()
    cds_idx = []
    cds_rows.apply(
        lambda row: cds_idx.append((row.start, row.end)),
        axis=1
    ).tolist()
    return cds_idx


def get_cds_rows(annotations: pd.DataFrame) -> pd.DataFrame:
    return annotations[
        (annotations.type == "CDS")
    ].set_index("parent_annotation_id")


def get_cds_annotation_idx(
    gene_row: pd.Series, 
    mrna_rows: pd.DataFrame, 
    cds_rows: pd.DataFrame,
    reference_sequence: SeqIO.SeqRecord,
    protein_path: Path
):
    mrna_rows.loc[:, 'cds_idx'] = mrna_rows.apply(lambda row: get_cds_sequence_idx(
        cds_rows.loc[row.annotation_id, :], 
        reference_sequence
    ), axis=1)
    # Norm the idx to the gene indices
    mrna_rows.loc[:, 'cds_idx_norm'] = mrna_rows.cds_idx.apply(lambda idx_list: [(idx[0] - gene_row.start, idx[1] - gene_row.start + 1) for idx in idx_list])
    # Get protein ids
    mrna_rows.loc[:, 'cds_protein_id'] = mrna_rows.apply(lambda row: get_cds_protein_id(
        cds_rows.loc[row.annotation_id, :]
    ), axis=1)
    cds_sequence_annotation_idx = mrna_rows.apply(
        lambda row: make_cds_annotation_map(
            row.cds_idx_norm, 
            row.cds_protein_id,
            protein_path
        ), 
        axis=1
    )
    cds_sequence_annotation_idx.name = "annotation_idx"
    cds_sequence_annotation_idx.index = mrna_rows.annotation_id
    # cds_sequence_annotations = 
    return cds_sequence_annotation_idx

# %% ../../nbs/03_build-translation-training-data.ipynb 51
def update_annotation_with_cds_annotation_idx(annotation: list[str], cds: dict):
    new_annotation = annotation.copy()
    for idx, value in cds.items():
        new_annotation[idx] = value
    return new_annotation
