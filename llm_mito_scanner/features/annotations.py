# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/03_build-translation-training-data.ipynb.

# %% auto 0
__all__ = ['get_sequence_from_file', 'make_attribute_dict_from_string', 'get_gene_id_from_attributes', 'write_gene_sequence',
           'write_annotation_sequences', 'get_protein_id_from_attributes', 'get_gene_to_protein_map_from_annotations']

# %% ../../nbs/03_build-translation-training-data.ipynb 3
import pandas as pd
from pathlib import Path
from tqdm.auto import tqdm
from Bio import SeqIO, Entrez
import re
import json
from multiprocessing import Pool
import os
import sys

pd.options.mode.chained_assignment = None

# %% ../../nbs/03_build-translation-training-data.ipynb 17
def get_sequence_from_file(
    start: int, end: int, strand: str = "+", 
    sequence_record: SeqIO.SeqRecord = None, fasta_path: Path = None) -> SeqIO.SeqRecord:
    """
    The Fasta file at fasta_path is a single record.
    If strand is positive, index and return sequence.
    If strand is negative, reverse the index and return.
    """
    if sequence_record is None and fasta_path is None:
        raise ValueError("Both sequence_record and fasta_path cannot be None")
    if sequence_record is None:
        sequence_record = next(SeqIO.parse(fasta_path.resolve(), "fasta"))
    if strand == "+":
        selected_sequence = sequence_record[start: end + 1]
    if strand == "-":
        selected_sequence = sequence_record[start - 1: end]
        selected_sequence = selected_sequence.reverse_complement()
    return selected_sequence.upper()

# %% ../../nbs/03_build-translation-training-data.ipynb 18
def make_attribute_dict_from_string(attr_str: str):
    attr_list = [attr.split("=") for attr in attr_str.split(";")]
    attr_dict = {attr_tuple[0]: attr_tuple[1] for attr_tuple in attr_list}
    return attr_dict


def get_gene_id_from_attributes(attributes: dict):
    dbxref_string = attributes.get("Dbxref", None)
    if dbxref_string is None:
        return
    pattern = re.compile('.*GeneID:(\d*).*')
    match = pattern.search(dbxref_string)
    gene_id = match.group(1)
    return gene_id


def write_gene_sequence(write_path: Path, gene_id: str, sequence_record: SeqIO.SeqRecord):
    sequence_path = write_path / f"{gene_id}.fasta"
    with sequence_path.open("w+") as out:
        SeqIO.write([sequence_record], out, "fasta")

# %% ../../nbs/03_build-translation-training-data.ipynb 19
# For every annotation, get genes, make fasta file for each
def write_annotation_sequences(args: dict):
    # Get input args
    annotation_file = Path(args.get("annotation_file"))
    genome_path = Path(args.get("genome_path"))
    sequences_path = Path(args.get("sequences_path"))
    # Load annotations
    annotation_file_df = pd.read_csv(annotation_file)
    # Get genes, extract attributes
    annotation_file_genes = annotation_file_df[annotation_file_df.type == "gene"]
    annotation_file_genes.loc[:, 'attr_dict'] = annotation_file_genes.attributes.apply(make_attribute_dict_from_string)
    annotation_file_genes.loc[:, 'gene_id'] = annotation_file_genes.attr_dict.apply(get_gene_id_from_attributes)
    # Filter those genes already extracted and written
    annotation_file_genes.loc[:, 'sequence_written'] = annotation_file_genes.gene_id.apply(
        lambda gene_id: (sequences_path / f"{gene_id}.fasta").exists()
    )
    gene_ids = annotation_file_genes.gene_id.unique().tolist()
    annotation_file_genes = annotation_file_genes[annotation_file_genes.sequence_written == False]
    if annotation_file_genes.shape[0] == 0:
        return gene_ids
    # Get fasta sequences
    fasta_path = genome_path / f"{annotation_file.stem}.fasta"
    fasta_sequence_record = next(SeqIO.parse(fasta_path.resolve(), "fasta"))
    annotation_file_sequence_records = annotation_file_genes.apply(
        lambda row: get_sequence_from_file(
            row.start,
            row.end,
            row.strand,
            fasta_sequence_record
        ),
        axis=1
    )
    annotation_file_sequence_records.name = "sequence_record"
    write_annotation_sequences = pd.concat(
        [
            annotation_file_sequence_records,
            annotation_file_genes.gene_id
        ], 
        axis=1
    )
    # Write sequences
    write_annotation_sequences.apply(
        lambda row: write_gene_sequence(
            write_path = sequences_path,
            gene_id = row.gene_id,
            sequence_record = row.sequence_record
        ),
        axis=1
    )
    return write_annotation_sequences.gene_id.unique().tolist()

# %% ../../nbs/03_build-translation-training-data.ipynb 23
def get_protein_id_from_attributes(attributes: dict):
    protein_id = attributes.get("protein_id", None)
    return protein_id


def get_gene_to_protein_map_from_annotations(annotation_file_path: Path) -> list[str]:
    annotations = pd.read_csv(annotation_file_path)
    genes = annotations[annotations.type == "CDS"]
    # Gather all gene ids
    gene_attributes = genes.attributes.apply(make_attribute_dict_from_string)
    gene_ids = gene_attributes.apply(get_gene_id_from_attributes)
    gene_ids.name = "gene_id"
    gene_protein_ids = gene_attributes.apply(get_protein_id_from_attributes)
    gene_protein_ids.name = "protein_id"
    gene_map = pd.concat([gene_ids, gene_protein_ids], axis=1).dropna().drop_duplicates()
    return gene_map.set_index("gene_id").protein_id.to_dict()
